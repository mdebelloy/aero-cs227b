<html>
  <head>
    <title>Aero</title>
    <script type='text/javascript' src='/epilog/javascript/epilog.js'></script>
    <script type='text/javascript' src='../javascript/localstorage.js'></script>
    <script type='text/javascript' src='../metagaming/grounder.js'></script>
    <script type='text/javascript' src='../metagaming/symbolizer.js'></script>
    <script type='text/javascript' src='../gameplaying/pts.js'></script>
    <script type='text/javascript' src='../reasoning/ground.js'></script>
    <script type='text/javascript'>

      //==============================================================================
      // aero.js
      //==============================================================================

      /*
        This week, following the assignment, we keep our MCTS player, but run it on grounded and symbolized
        rules. We tested the three players (last week's with no grounding, grounding with the general interpreter,
        and symbolizing) on Hunter, Connect 4 and Tic Tac Toe. For Hunter, the Grounded Interpreter performs better
        than the General Interpreter on ground rules, and both are beatan by the No Grounding player achieves the most
        depth charges (as seen in the table below). This is likely due to the fact that Hunter has a somewhwat simple rule 
        structure where grounding introduces overhead without significant benefits. For Connect 4, the General Interpreter
        had more depth charges during the headstart period than the No Grounding player. Finally, in Tic-tac-toe,
        both the General Interpreter and Grounded Interpreter significantly outperformed the No Grounding player,
        with the Grounded Interpreter getting the largest number of depth charges. 

        | Game        | Player Type           | Depth Charges (Headstart)   | Nodes Explored (Headstart)  | Depth Charges (Move 1) | Nodes Explored (Move 1) |
        |-------------|------------------------|----------------------------|-----------------------------|------------------------|-------------------------|
        | Hunter      | No Grounding           | 124,460                    | 17,800                      | 266,318                | 38,545                  |
        | Hunter      | General Interpreter    | 71,091                     | 9,310                       | 93,932                 | 15,447                  |
        | Hunter      | Grounded Interpreter   | 93,888                     | 12,831                      | 92,698                 | 15,736                  |
        | Connect4    | No Grounding           | 22,668                     | 1,162                       | 51,690                 | 2,651                   |
        | Connect4    | General Interpreter    | 39,412                     | 2,057                       | 47,393                 | 2,608                   |
        | Connect4    | Grounded Interpreter   | 30,531                     | 1,569                       | 33,736                 | 1,776                   |
        | Tic-tac-toe | No Grounding           | 139,114                    | 48,307                      | 300,442                | 105,705                 |
        | Tic-tac-toe | General Interpreter    | 226,346                    | 91,035                      | 181,180                | 108,558                 |
        | Tic-tac-toe | Grounded Interpreter   | 261,114                    | 110,234                     | 211,459                | 135,014                 |


        We clearly see that grounding and symbolizing is not always worthwile. We also note some differences between our 
        results and those from the slides' grounding experiments. This may imply that our implementation is somewhat
        flawed, and still needs some work. The implementation is mostly the same as last week's: We are running
        MCTS using Upper Confidence Bounds with both a headstart and bigswitch strategy. However, during the start 
        period, we are attempting to ground and symbolize the rules. If this fails or times out, we fall back to the 
        general interpreter.


      */


      var manager = 'manager';
      var player = 'aero';

      var role = 'robot';
      var rules = [];
      var startclock = 10;
      var playclock = 10;

      var library = [];
      var roles = [];
      var state = [];

      var tree;
      var C = 1.0; 
      var depthCharges = 0;
      var nodesExplored = 0;
      var metrics = false;
      var logging = false;
      var useSymbol = false;  

      // Store original functions to restore them if needed
      var originalFindinits = findinits;
      var originalFindlegals = findlegals;
      var originalSimulate = simulate;
      var originalFindcontrol = findcontrol;
      var originalFindterminalp = findterminalp;
      var originalFindreward = findreward;

      /* shuffle(arr): Shuffles an input array in place. */
      function shuffle(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        return array;
      }

      /* numberize(str): Converts a string to a number. */
      function numberize(str) {
        return parseInt(str);
      }

      /**
       * Start function - initializes the player
       */
      function start(r, rs, sc, pc) {
        role = r;
        rules = rs.slice(1);
        startclock = numberize(sc);
        playclock = numberize(pc);

        // Reset metrics
        if (metrics) {
          depthCharges = 0;
          nodesExplored = 0;
        }

        console.log("Starting with " + rules.length + " rules");
        
        // First define the rules using the general approach
        rules = definemorerules([], rules);
        
        // Try to ground the rules
        console.log("Attempting to ground rules...");
        const groundDeadline = Date.now() + (startclock * 500); // Use half the start clock
        const groundedRules = groundrules(rules, groundDeadline);
        
        if (groundedRules) {
          console.log("Grounding successful: " + groundedRules.length + " ground rules");
          
          // Try to symbolize the ground rules
          try {
            console.log("Attempting to symbolize ground rules...");
            const symbolizedRules = symbolizerules(groundedRules);
            rules = symbolizedRules;
            useSymbol = true;
            
            // Override interpreter functions with symbol.js versions
            window.findinits = symbfindinits;
            window.findlegals = symbfindlegals;
            window.simulate = symbsimulate;
            window.findcontrol = symbfindcontrol;
            window.findterminalp = symbfindterminalp;
            window.findreward = symbfindreward;
            
            console.log("Using symbol interpreter");
          } catch (error) {
            console.warn("Symbolization failed: " + error);
            // Fall back to original interpreter
            useSymbol = false;
            console.log("Using general interpreter");
          }
        } else {
          console.log("Grounding failed or timed out, using original rules");
          useSymbol = false;
          console.log("Using general interpreter");
        }
        
        // Build the final library
        library = definemorerules([], rules);
        roles = findroles(library);
        state = findinits(library);
        
        // Create initial MCTS tree
        tree = makenode(state, findcontrol(state, library), 0);
        
        // Use any remaining startclock time for initial MCTS search
        const headstartDeadline = Date.now() + Math.max(1, startclock - 2) * 1000;
        let iterations = 0;
        
        while (Date.now() < headstartDeadline) {
          process(tree, headstartDeadline);
          iterations++;
          if(logging == true){
            if (iterations % 1000 === 0) {
              var timeRemaining = Math.max(0, (headstartDeadline - Date.now()) / 1000);
              console.log("Headstart - Time remaining: " + timeRemaining.toFixed(1) + 
                          "s, iterations: " + iterations);
            }
          }
        }
        
        if (metrics) {
          console.log("Headstart complete - " + iterations + " iterations, " + 
                      depthCharges + " depth charges, " + nodesExplored + " nodes explored");
        }
        
        return "ready";
      }

      /**
       * Play function - chooses the next move
       */
      function play(move) {
        // Handle symbolization for moves if necessary
        if (useSymbol && move !== nil && move !== null) {
          move = symbolizeatom(move);
        }
        
        // Update state if a move was provided
        if (move !== nil) {
          state = simulate(move, state, library);
          tree = subtree(move, tree);
        }
        
        // Check if it's our turn
        if (findcontrol(state, library) !== role) {
          return false;
        }
        
        // Reset metrics for this turn
        if (metrics) {
          depthCharges = 0;
          nodesExplored = 0;
        }
        
        // Check for threats - opponent moves that could lead to immediate loss
        const opponentMoves = findlegals(state, library);
        const threats = opponentMoves.filter(move => {
          const nextState = simulate(move, state, library);
          return findterminalp(nextState, library) && 
                parseInt(findreward(role, nextState, library)) === 0;
        });
        
        if (threats.length > 0) {
          console.log("Found " + threats.length + " threatening moves, looking for counter");
          const myMoves = shuffle(findlegals(state, library));
          
          // Look for a move that prevents all threats
          for (let i = 0; i < myMoves.length; i++) {
            const myMove = myMoves[i];
            const afterMyMove = simulate(myMove, state, library);
            const opponentReplies = findlegals(afterMyMove, library);
            
            if (threats.every(threat => !opponentReplies.includes(threat))) {
              console.log("Found defensive move against threats");
              return useSymbol ? unsymbolizeatom(myMove) : myMove;
            }
          }
          
          // If no perfect defense, just pick the first move
          console.log("No perfect defense found, using first legal move");
          return useSymbol ? unsymbolizeatom(myMoves[0]) : myMoves[0];
        }
        
        // Run MCTS search until near playclock deadline
        const deadline = Date.now() + (playclock - 1) * 1000;
        let iterations = 0;
        
        while (Date.now() < deadline) {
          process(tree, deadline);
          iterations++;
          if(logging == true){
            if (iterations % 1000 === 0) {
              const timeRemaining = Math.max(0, (deadline - Date.now()) / 1000);
              console.log("Time remaining: " + timeRemaining.toFixed(1) + "s, iterations: " + iterations);
            }
          }
        }
        
        // Select best move
        const bestMove = selectBestMove(tree);
        
        if (metrics) {
          console.log("Move selected after " + iterations + " iterations");
          console.log("- Depth charges: " + depthCharges);
          console.log("- Nodes explored: " + nodesExplored);
          console.log("- Selected move: " + bestMove);
        }
        
        // If using symbolization, convert back to original representation
        return useSymbol ? unsymbolizeatom(bestMove) : bestMove;
      }

      /**
       * Creates an MCTS node
       */
      function makenode(state, mover, reward) {
        if (metrics) {
          nodesExplored++;
        }
        
        return {
          state: state,
          actions: [],
          children: [],
          mover: mover,
          utility: reward,
          visits: 0,
          isTerminal: findterminalp(state, library),
          untried: null  // Will be initialized during expansion
        };
      }

      /**
       * Process an MCTS node (recursively)
       */
      function process(node, deadline) {
        if (Date.now() >= deadline) return false;
        
        // Selection
        while ((!node.untried || node.untried.length === 0) && node.children.length > 0) {
          node = select(node);
          if (node.isTerminal) {
            node.utility = parseInt(findreward(role, node.state, library));
            node.visits += 1;
            return true;
          }
        }
        
        // Expansion
        if (!node.untried) {
          // Initialize untried actions if this is the first visit
          node.untried = shuffle(findlegals(node.state, library));
        }
        
        if (node.untried.length > 0) {
          const action = node.untried.pop();
          const newState = simulate(action, node.state, library);
          const newControl = findcontrol(newState, library);
          const terminal = findterminalp(newState, library);
          
          const childNode = makenode(newState, newControl, 0);
          childNode.isTerminal = terminal;
          
          node.actions.push(action);
          node.children.push(childNode);
          
          if (terminal) {
            childNode.utility = parseInt(findreward(role, newState, library));
            childNode.visits = 1;
            update(node, childNode.utility);
            return true;
          }
          
          // Simulation
          const reward = runDepthCharge(newState);
          childNode.utility = reward;
          childNode.visits = 1;
          
          // Backpropagation
          update(node, reward);
          return true;
        }
        
        return true;
      }

      /**
       * Select the most promising child node using UCB formula
       */
      function select(node) {
        let bestChild = node.children[0];
        let bestScore = ucbValue(bestChild, node.visits);
        
        for (let i = 1; i < node.children.length; i++) {
          const child = node.children[i];
          const score = ucbValue(child, node.visits);
          if (score > bestScore) {
            bestChild = child;
            bestScore = score;
          }
        }
        
        return bestChild;
      }

      /**
       * Calculate UCB value for a node
       */
      function ucbValue(node, parentVisits) {
        if (node.visits === 0) return Infinity;
        return (node.utility / node.visits) + C * Math.sqrt(Math.log(parentVisits) / node.visits);
      }

      /**
       * Update a node's statistics and propagate up the tree
       */
      function update(node, reward) {
        node.visits += 1;
        node.utility += reward;
        return true;
      }

      /**
       * Run a random playout from the given state
       */
      function runDepthCharge(state) {
        depthCharges++;
        
        if (findterminalp(state, library)) {
          return parseInt(findreward(role, state, library));
        }
        
        const actions = findlegals(state, library);
        if (actions.length === 0) {
          return 0;
        }
        
        const randomIndex = Math.floor(Math.random() * actions.length);
        const newState = simulate(actions[randomIndex], state, library);
        
        return runDepthCharge(newState);
      }

      /**
       * Find the subtree corresponding to the given move
       */
      function subtree(move, node) {
        if (node.children.length === 0) {
          // If no children, first expand the node
          if (!node.untried) {
            node.untried = shuffle(findlegals(node.state, library));
          }
          
          while (node.untried.length > 0) {
            const action = node.untried.pop();
            const newState = simulate(action, node.state, library);
            const newControl = findcontrol(newState, library);
            const isTerminal = findterminalp(newState, library);
            
            const childNode = makenode(newState, newControl, 0);
            childNode.isTerminal = isTerminal;
            
            node.actions.push(action);
            node.children.push(childNode);
            
            if (equalp(move, action)) {
              return childNode;
            }
          }
          
          // If we didn't find the move, create a new node
          const newState = simulate(move, node.state, library);
          return makenode(newState, findcontrol(newState, library), 0);
        }
        
        // Look for matching move in existing children
        for (let i = 0; i < node.actions.length; i++) {
          if (equalp(move, node.actions[i])) {
            return node.children[i];
          }
        }
        
        // If not found, create a new node
        const newState = simulate(move, node.state, library);
        return makenode(newState, findcontrol(newState, library), 0);
      }

      /**
       * Select the best move from the current tree
       */
      function selectBestMove(node) {
        if (!node.children || node.children.length === 0) {
          // If no children, get any legal move
          return findlegals(node.state, library)[0];
        }
        
        // Look for winning moves first
        for (let i = 0; i < node.children.length; i++) {
          if (node.children[i].isTerminal && node.children[i].utility === 100) {
            console.log("Found winning move!");
            return node.actions[i];
          }
        }
        
        // Select move with highest visit count
        let bestIndex = 0;
        let bestVisits = node.children[0].visits;
        
        for (let i = 1; i < node.children.length; i++) {
          if (node.children[i].visits > bestVisits) {
            bestIndex = i;
            bestVisits = node.children[i].visits;
          }
        }
        
        console.log("Selected move with " + bestVisits + " visits");
        return node.actions[bestIndex];
      }

      /* shuffle(arr): Shuffles an input array in place. */
      function shuffle(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        return array;
      }

      /* numberize(str): Converts a string to a number. */
      function numberize(str) {
        return parseInt(str);
      }

      // Support functions
      function stop(move) { return false; }
      function abort() { return false; }
      function ping() { return "ready"; }

//==============================================================================
// End of player code
//==============================================================================
      </script>
  </head>

  <body bgcolor='#aabbbb' onload='doinitialize()'>
    <center>
      <table width='720' cellspacing='0' cellpadding='40' bgcolor='#ffffff'>
        <tr>
          <td>

            <center>
              <table width='640' cellpadding='0'>
                <tr>
                  <td width='180' align='center' valign='center'>
                    <img width='130' src='http://gamemaster.stanford.edu/images/ggp.jpg'/>
                  </td>
                  <td align='center'>
                    <span style='font-size:18pt'>&nbsp;</span>
                    <span style='font-size:32pt'>Gamemaster</span><br/>
                  </td>
                  <td width='180' align='center' style='color:#000066;font-size:18px'>
                    <i>General<br/>Game<br/>Playing</i>
                  </td>
                </tr>
              </table>
            </center>

            <br/>
            <table width='640' cellpadding='8' cellspacing='0' bgcolor='#f4f8f8' border='1'>
              <tr height='40'>
                 <td align='center'>
                  <table style='color:#000066;font-size:18px'>
                    <tr>
                      <td>
                  Protocol: localstorage<br/>
                  Strategy: mctsWithIndexingAndDepthCharges<br/>
                  Identifier: <span id='player'>aero</span> <img src="http://gamemaster.stanford.edu/images/pencil.gif" onclick='doplayer()'/>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
            <br/>

            <center>
              <br/>
              <textarea id='transcript' style='font-family:courier' rows='30' cols='80' readonly></textarea>
            </center>

          </td>
        </tr>
      </table>
    </center>
  </body>
</html>