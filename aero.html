<html>
  <head>
    <title>Aero</title>
    <script type='text/javascript' src='/epilog/javascript/epilog.js'></script>
    <script type='text/javascript' src='../javascript/localstorage.js'></script>
    <script type='text/javascript' src='../metagaming/grounder.js'></script>
    <script type='text/javascript' src='../metagaming/symbolizer.js'></script>
    
    <script type='text/javascript' src='../reasoning/symbol.js'></script>
    <script>
      var symbolFindinits = findinits;
      var symbolFindlegals = findlegals;
      var symbolSimulate = simulate;
      var symbolFindcontrol = findcontrol;
      var symbolFindterminalp = findterminalp;
      var symbolFindreward = findreward;
    </script>
    
    <script type='text/javascript' src='../gameplaying/pts.js'></script>
    <script type='text/javascript' src='../reasoning/ground.js'></script>
    <script>
      var generalFindinits = findinits;
      var generalFindlegals = findlegals;
      var generalSimulate = simulate;
      var generalFindcontrol = findcontrol;
      var generalFindterminalp = findterminalp;
      var generalFindreward = findreward;
    </script>
    <script type='text/javascript' src='../metagaming/pruner.js'></script>
    <script type='text/javascript' src='../metagaming/optimizer.js'></script>
    <script type="text/javascript" src="../metagaming/simplifier.js"></script>
    <script type='text/javascript'>

      //==============================================================================
      // aero.js
      //==============================================================================

      /*

      The implementation is MCTS with a couple of modification. Following the cadia player paper
      found online, we implement UCT and Gibbs Sampling for our move selection. Also, to 
      decrease variance in depth charges, we run them each four times and average over the four. 
      This technique is inspired from the hans_magnus player. We spent some time playing with 
      the hyperparameters and ended up using UCT C = 45, averaging over 4 depth charges, 
      and using a temperature tau of 2 for Gibbs sampling. The player also avoids
      direct one turn losses

      Our player seems to perform relatively well, especially in games with large state spaces.
      However, we note that it's objective is simply to maximize it's score without losing,
      so it has a tendancy to give points to the opponent in games like alquerque, on the 
      offchance that the other player will mess up and make a non-optimal move. This makes
      our player best at games where maximizing out own score without care for the opponent's
      score is best.

      */
     
      var manager = 'manager';
      var player = 'aero';

      var role = 'robot';
      var rules = [];
      var startclock = 10;
      var playclock = 10;

      var library = [];
      var roles = [];
      var state = [];

      var tree;
      var C = 45; // UCT exploration
      var tau = 2; // temp for gibbs sampling
      var depthCharges = 0;
      var nodesExplored = 0;
      var metrics = true; 
      var logging = false;
      var useSymbol = false;
      var usePrune = true;
      var actionHistory = {}; 

      var findinitsFn,
          findlegalsFn,
          simulateFn,
          findcontrolFn,
          findterminalpFn,
          findrewardFn;

      // shuffle array in place
      function shuffle(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        return array;
      }

      // convert string to number
      function numberize(str) {
        return parseInt(str);
      }

      // update metrics display in html
      function updateMetricsDisplay(depthCharges, nodesExplored, moveInfo, moveValue) {
        const metricsBox = document.getElementById('metrics-box');
        if (metricsBox) {
          metricsBox.innerHTML = `
            <div><strong>Grounding:</strong> ${useSymbol ? "true" : "false"} <strong>Pruning:</strong> ${usePrune ? "true" : "false"}</div>
            <div><strong>Depth Charges:</strong> ${depthCharges}</div>
            <div><strong>Nodes Explored:</strong> ${nodesExplored}</div>
            <div><strong>Move Selection:</strong> ${moveInfo || 'N/A'}</div>
            <div><strong>Move Value:</strong> ${moveValue !== undefined ? moveValue.toFixed(2) : 'N/A'}</div>
          `;
        }
      }

      // initialize game with rules optimization and precomputation
      function start(r, rs, sc, pc) {
        role = r;
        rules = rs.slice(1);
        startclock = numberize(sc);
        playclock = numberize(pc);

        depthCharges = 0;
        nodesExplored = 0;
        updateMetricsDisplay(depthCharges, nodesExplored);

        rules = prunerulesubgoals(rules);
        rules = prunerules(rules);
        rules = fixrules(rules);
        
        rules = definemorerules([], rules);
        
        const optimizationDeadline = Date.now() + (startclock / 2) * 1000;
        const grounded = groundrules(rules, optimizationDeadline - Date.now());

        if (grounded !== false) {
          try {
            rules = symbolizerules(grounded);
            useSymbol = true;
            
            findinitsFn = symbolFindinits;
            findlegalsFn = symbolFindlegals;
            simulateFn = symbolSimulate;
            findcontrolFn = symbolFindcontrol;
            findterminalpFn = symbolFindterminalp;
            findrewardFn = symbolFindreward;
            
            rules = simplifyrules(rules);
            
            rules = definemorerules([], rules);
            rules = pruneprogram(role, rules);
          } catch (error) {
            useSymbol = false;
            rules = grounded;
            setupGeneralInterpreter();
          }
        } else {
          useSymbol = false;
          setupGeneralInterpreter();
        }

        rules = definemorerules([], rules);
        library = definemorerules([], rules);
        roles = findroles(library);
        state = findinitsFn(library);
        
        var reward = parseInt(findrewardFn(role, state, library));
        tree = makeNode(state, null, null);
        tree.terminal = false;

        const headstartDeadline = Date.now() + startclock * 1000;
        let iterations = 0;

        while (Date.now() < headstartDeadline) {
          processMCS(tree);
          iterations++;
          
          if (logging && iterations % 1000 === 0) {
            var timeRemaining = Math.max(0, (headstartDeadline - Date.now()) / 1000);
          }
        }

        updateMetricsDisplay(depthCharges, nodesExplored, "Headstart complete");

        return "ready";
      }

      // setup the general interpreter functions
      function setupGeneralInterpreter() {
        findinitsFn = generalFindinits;
        findlegalsFn = generalFindlegals;
        simulateFn = generalSimulate;
        findcontrolFn = generalFindcontrol;
        findterminalpFn = generalFindterminalp;
        findrewardFn = generalFindreward;
      }

      // play a move in the game with threat detection and mcts
      function play(rawMove) {
        var move = rawMove;

        if (useSymbol && move !== nil && move !== null) {
          move = symbolizeatom(move);
        }

        if (move !== nil && move !== null) {
          tree = subtree(move, tree);
          state = tree.state;
        }

        if (findcontrolFn(state, library) !== role) {
          return false;
        }

        depthCharges = 0;
        nodesExplored = 0;
        updateMetricsDisplay(depthCharges, nodesExplored);

        const opponentMoves = findlegalsFn(state, library);
        const oneturnLosses = opponentMoves.filter(function(opponentMove) {
          const nextState = simulateFn(opponentMove, state, library);
          return findterminalpFn(nextState, library) && 
                parseInt(findrewardFn(role, nextState, library)) === 0;
        });

        if (oneturnLosses.length > 0) {
          const myMoves = shuffle(findlegalsFn(state, library));
          
          for (let i = 0; i < myMoves.length; i++) {
            const curMove = myMoves[i];
            const afterMyMove = simulateFn(curMove, state, library);
            const opponentReplies = findlegalsFn(afterMyMove, library);
            
            if (findterminalpFn(afterMyMove, library) && 
                parseInt(findrewardFn(role, afterMyMove, library)) === 100) {
              updateMetricsDisplay(depthCharges, nodesExplored, "Immediate win", 1.0);
              return useSymbol ? unsymbolizeatom(curMove) : curMove;
            }
            
            if (oneturnLosses.every(function(loss) { 
              return !opponentReplies.includes(loss); 
            })) {
              updateMetricsDisplay(depthCharges, nodesExplored, "Avoiding one-turn loss", 0.5);
              return useSymbol ? unsymbolizeatom(curMove) : curMove;
            }
          }
        }

        const bestMove = playmcs();
        return useSymbol ? unsymbolizeatom(bestMove) : bestMove;
      }

      // run mcts algorithm until time runs out
      function playmcs() {
        const deadline = Date.now() + Math.max(playclock - 1, 0) * 1000;
        let iterations = 0;

        while (Date.now() < deadline && !tree.terminal) {
          processMCS(tree);
          iterations++;
          
          if (logging && iterations % 1000 === 0) {
            const timeRemaining = Math.max(0, (deadline - Date.now()) / 1000);
          }
        }

        return selectBestMove(tree);
      }

      // create a new node for the game tree
      function makeNode(state, parent, move) {
        nodesExplored++;
        
        const terminal = findterminalpFn(state, library);
        const untried = terminal ? [] : shuffle(findlegalsFn(state, library));
        
        return {
          state: state,
          parent: parent,
          move: move,
          w: 0,
          n: 0,
          children: [],
          untried: untried,
          terminal: terminal,
          determined: false
        };
      }

      // perform one iteration of monte carlo tree search
      function processMCS(root) {
        var node = root;

        while (node.untried.length === 0 && node.children.length > 0 && !node.terminal) {
          node = bestUCTChild(node);
        }

        if (node.terminal) {
          if (!node.determined) {
            determineTerminal(node);
          }
          return;
        }

        if (node.untried.length > 0) {
          const move = node.untried.pop();
          const newState = simulateFn(move, node.state, library);
          const child = makeNode(newState, node, move);
          node.children.push(child);
          
          if (child.terminal) {
            determineTerminal(child);
            node = child;
          } else {
            const numProbes = 4;
            let totalReward = 0;
            
            for (let i = 0; i < numProbes; i++) {
              totalReward += runDepthCharge(child.state);
            }
            
            const avgReward = totalReward / numProbes;
            backprop(child, avgReward);
            return;
          }
        }
        
        if (!node.determined) {
          const reward = runDepthCharge(node.state);
          backprop(node, reward);
        }
      }

      // update node statistics up the tree
      function backprop(node, reward) {
        while (node) {
          node.n += 1;
          node.w += reward;
          node = node.parent;
        }
      }

      // evaluate terminal nodes using minimax principles
      function determineTerminal(node) {
        node.determined = true;
        
        if (findterminalpFn(node.state, library)) {
          node.w = parseInt(findrewardFn(role, node.state, library));
          node.n = 1;
          node.terminal = true;
        } else {
          let allDetermined = true;
          
          if (node.children.length === 0 && node.untried.length > 0) {
            while (node.untried.length > 0) {
              const move = node.untried.pop();
              const newState = simulateFn(move, node.state, library);
              const child = makeNode(newState, node, move);
              node.children.push(child);
              
              if (child.terminal) {
                determineTerminal(child);
              } else {
                allDetermined = false;
              }
            }
          }
          
          for (let i = 0; i < node.children.length; i++) {
            if (!node.children[i].determined) {
              allDetermined = false;
              break;
            }
          }
          
          if (allDetermined && node.children.length > 0) {
            if (findcontrolFn(node.state, library) === role) {
              let maxReward = node.children[0].w;
              for (let i = 1; i < node.children.length; i++) {
                if (node.children[i].w > maxReward) {
                  maxReward = node.children[i].w;
                }
              }
              node.w = maxReward;
            } else {
              let minReward = node.children[0].w;
              for (let i = 1; i < node.children.length; i++) {
                if (node.children[i].w < minReward) {
                  minReward = node.children[i].w;
                }
              }
              node.w = minReward;
            }
            
            node.n = 1;
            node.terminal = true;
            
            if (node.parent) {
              if ((node.w === 100 && findcontrolFn(node.parent.state, library) === role) ||
                  (node.w === 0 && findcontrolFn(node.parent.state, library) !== role)) {
                determineTerminal(node.parent);
              }
            }
          } else {
            node.determined = false;
          }
        }
      }

      // select best child node using uct formula
      function bestUCTChild(node) {
        var bestScore = -Infinity;
        var bestNode = null;

        for (var i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          
          if (child.determined && child.terminal && child.w === 0) {
            continue;
          }
          
          if (child.determined && child.terminal && child.w === 100) {
            return child;
          }
          
          if (child.n === 0) {
            return child;
          }
          
          const exploit = child.w / child.n;
          const explore = C * Math.sqrt(Math.log(node.n) / child.n);
          const score = exploit + explore;

          if (score > bestScore) {
            bestScore = score;
            bestNode = child;
          }
        }

        return bestNode || node.children[0];
      }

      // find or create subtree for a given move
      function subtree(move, node) {
        if (!node.children || node.children.length === 0) {
          const newState = simulateFn(move, node.state, library);
          return makeNode(newState, null, null);
        }
        
        for (var i = 0; i < node.children.length; i++) {
          if (equalp(move, node.children[i].move)) {
            node.children[i].parent = null;
            return node.children[i];
          }
        }
        
        const newState = simulateFn(move, node.state, library);
        return makeNode(newState, null, null);
      }

      // select best move based on tree statistics
      function selectBestMove(root) {
        if (!root.children || root.children.length === 0) {
          const legals = findlegalsFn(root.state, library);
          return legals.length > 0 ? legals[0] : null;
        }
        
        for (let i = 0; i < root.children.length; i++) {
          const child = root.children[i];
          
          if (child.determined && child.terminal && child.w === 100) {
            updateMetricsDisplay(depthCharges, nodesExplored, "Proven win", 1.0);
            return child.move;
          }
        }
        
        const viableChildren = root.children.filter(function(child) {
          return !(child.determined && child.terminal && child.w === 0);
        });
        
        if (viableChildren.length === 0) {
          const bestChild = root.children.reduce(function(best, current) {
            return current.n > best.n ? current : best;
          }, root.children[0]);
          
          updateMetricsDisplay(depthCharges, nodesExplored, "Delaying loss", bestChild.w / bestChild.n);
          return bestChild.move;
        }
        
        let bestChild = viableChildren[0];
        let bestValue = bestChild.w / bestChild.n;
        
        for (let i = 1; i < viableChildren.length; i++) {
          const child = viableChildren[i];
          const value = child.w / child.n;
          
          if (value > bestValue) {
            bestValue = value;
            bestChild = child;
          }
        }
        
        updateMetricsDisplay(depthCharges, nodesExplored, 
                           "MCTS selection (" + bestChild.n + " visits)", 
                           bestChild.w / bestChild.n);
        
        return bestChild.move;
      }

      // perform random playout to terminal state
      function runDepthCharge(s) {
        depthCharges++;
        var state = s;
        var reward = 0;

        while (!findterminalpFn(state, library)) {
          const moves = findlegalsFn(state, library);
          if (moves.length === 0) break;
          
          state = simulateFn(moves[Math.floor(Math.random() * moves.length)], state, library);
        }

        reward = parseInt(findrewardFn(role, state, library), 10);
        return reward;
      }

      function stop(move) { 
        return false; 
      }

      function abort() { 
        return false; 
      }

      function ping() { 
        return "ready"; 
      }

//==============================================================================
// End of player code
//==============================================================================
      </script>
  </head>

  <body bgcolor='#aabbbb' onload='doinitialize()'>
    <center>
      <table width='720' cellspacing='0' cellpadding='40' bgcolor='#ffffff'>
        <tr>
          <td>

            <center>
              <table width='640' cellpadding='0'>
                <tr>
                  <td width='180' align='center' valign='center'>
                    <img width='130' src='http://gamemaster.stanford.edu/images/ggp.jpg'/>
                  </td>
                  <td align='center'>
                    <span style='font-size:18pt'>&nbsp;</span>
                    <span style='font-size:32pt'>Gamemaster</span><br/>
                  </td>
                  <td width='180' align='center' style='color:#000066;font-size:18px'>
                    <i>General<br/>Game<br/>Playing</i>
                  </td>
                </tr>
              </table>
            </center>

            <br/>
            <table width='640' cellpadding='8' cellspacing='0' bgcolor='#f4f8f8' border='1'>
              <tr height='40'>
                 <td align='center'>
                  <table style='color:#000066;font-size:18px'>
                    <tr>
                      <td>
                  Protocol: localstorage<br/>
                  Strategy: mcts + Gibbs Sampling + immediate loss prevention <br/>
                  Identifier: <span id='player'>aero</span> <img src="http://gamemaster.stanford.edu/images/pencil.gif" onclick='doplayer()'/>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
            <br/>

            <!-- New metrics box -->
            <table width='640' cellpadding='8' cellspacing='0' bgcolor='#e8f0f0' border='1'>
              <tr>
                <td>
                  <div style='color:#000066;font-weight:bold;font-size:18px;margin-bottom:5px;'>MCTS Metrics</div>
                  <div id='metrics-box' style='font-family:courier;font-size:14px;'>
                    <div><strong>Depth Charges:</strong> 0</div>
                    <div><strong>Nodes Explored:</strong> 0</div>
                    <div><strong>Move Selection:</strong> N/A</div>
                    <div><strong>Move Value:</strong> N/A</div>
                  </div>
                </td>
              </tr>
            </table>
            <br/>

            <center>
              <br/>
              <textarea id='transcript' style='font-family:courier' rows='30' cols='80' readonly></textarea>
            </center>

          </td>
        </tr>
      </table>
    </center>
  </body>
</html>