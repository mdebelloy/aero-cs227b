<html>
  <head>
    <title>Aero</title>
    <script type='text/javascript' src='/epilog/javascript/epilog.js'></script>
    <script type='text/javascript' src='../javascript/localstorage.js'></script>
    <script type='text/javascript' src='../metagaming/grounder.js'></script>
    <script type='text/javascript' src='../metagaming/symbolizer.js'></script>
    
    <script type='text/javascript' src='../reasoning/symbol.js'></script>
    <script>
      var symbolFindinits = findinits;
      var symbolFindlegals = findlegals;
      var symbolSimulate = simulate;
      var symbolFindcontrol = findcontrol;
      var symbolFindterminalp = findterminalp;
      var symbolFindreward = findreward;
    </script>
    
    <script type='text/javascript' src='../gameplaying/pts.js'></script>
    <script type='text/javascript' src='../reasoning/ground.js'></script>
    <script>
      var generalFindinits = findinits;
      var generalFindlegals = findlegals;
      var generalSimulate = simulate;
      var generalFindcontrol = findcontrol;
      var generalFindterminalp = findterminalp;
      var generalFindreward = findreward;
    </script>
    <script type='text/javascript' src='../metagaming/pruner.js'></script>
    <script type='text/javascript' src='../metagaming/optimizer.js'></script>
    <script type="text/javascript" src="../metagaming/simplifier.js"></script>
    <script type='text/javascript'>

      //==============================================================================
      // aero.js
      //==============================================================================

      /*

      Our player this week adds pruning to the MCTS implemenation with groudning and symbolizing from last week.
      Most of the effort was spent fixing the player that consisitently errored out last week. Once grounding
      and symbolizing were fixed, we also added in pruning, as was asked for in this assignment. This was then
      tested on both multiplebuttonsandlights and multiplehunter with and without pruning. The results are 
      shown in the table below. We also decide to replace the UCB search with UCT, which is more approrpriate
      for trees. This was done after reading the "Ary, a general game playing program" paper by Jean MÃ©hat and
      Tristan Cazenave. This change should help the algorithm make better sequential decisions. After playing
      around with the C exploration vs exploitation constant in a few different games, C was set to 10. The 
      remaining algorithm uses MCTS like before, also looking for one turn losses to differentiate between 
      values from unexplored states and immediate losses.



      | Game                     | Pruning | Phase       | Depth Charges  | Nodes Explored | Tree Size  | Max Depth   | 
      |--------------------------|---------|-------------|----------------|----------------|------------|-------------|
      | Multiplebuttonsandlights | No      | Startclock   | 21926          | 21927          | 21927      | 14         |
      |                          | No      | First Move   | 27667          | 27667          | 49594      | 15         |
      |                          | Yes     | Startclock   | 22151          | 22152          | 22152      | 18         |
      |                          | Yes     | First Move   | 28502          | 28502          | 70720      | 19         |
      | Multiplehunter           | No      | Startclock   | 9756           | 9757           | 9757       | 30         |
      |                          | No      | First Move   | 11267          | 11267          | 21024      | 37         |
      |                          | Yes     | Startclock   | 9172           | 9173           | 9173       | 36         |
      |                          | Yes     | First Move   | 8788           | 8788           | 17961      | 45         |


      We first note that, since pruning takes time, during the start clock, the algorithm does fewer depth charges.
      We also note that during the first move, the number of depth charges and the tree size are relatively similar
      with and without pruning. However,  the tree size increases substantially with pruning enabled, which implies
      that the smaller rule set lets us explore further. This is confirmed by seeing that the maximum depth of the 
      tree searched increases significantly with pruning. In these two games, it is clear that pruning allows
      for a deeper exploration of the game tree. 

      */

      var manager = 'manager';
      var player = 'aero';

      var role = 'robot';
      var rules = [];
      var startclock = 10;
      var playclock = 10;

      var library = [];
      var roles = [];
      var state = [];

      var tree;
      var C = 10; 
      var depthCharges = 0;
      var nodesExplored = 0;
      var metrics = false;
      var logging = false;
      var useSymbol = false;
      var usePrune = true;

      var findinitsFn,
          findlegalsFn,
          simulateFn,
          findcontrolFn,
          findterminalpFn,
          findrewardFn;

      // shuffle array in place
      function shuffle(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        return array;
      }

      // convert string to number
      function numberize(str) {
        return parseInt(str);
      }

      // start function with pruning, grounding, and symbolizing
      function start(r, rs, sc, pc) {
        role = r;
        rules = rs.slice(1);
        startclock = numberize(sc);
        playclock = numberize(pc);

        if (metrics) {
          depthCharges = 0;
          nodesExplored = 0;
        }

        if (usePrune){
          console.log("Using pruning")
          rules = prunerulesubgoals(rules);
          rules = prunerules(rules);
          rules = fixrules(rules);
        }
        else{
          console.log("Not using pruning")
        }

        console.log("Starting with " + rules.length + " rules");
        rules = definemorerules([], rules);

        console.log("Attempting to ground rules...");
        const grounded = groundrules(rules, startclock * 500);

        if (grounded !== false) {
          console.log("Grounding successful, attempting symbolization");
          try {
            rules = symbolizerules(grounded);
            useSymbol = true;

            findinitsFn = symbolFindinits;
            findlegalsFn = symbolFindlegals;
            simulateFn = symbolSimulate;
            findcontrolFn = symbolFindcontrol;
            findterminalpFn = symbolFindterminalp;
            findrewardFn = symbolFindreward;

            console.log("Using symbol interpreter");
          } catch (error) {
            console.log("Symbolization failed: " + error);
            useSymbol = false;
            rules = grounded;
            setupGeneralInterpreter();
          }
        } else {
          console.log("Grounding failed, using general interpreter");
          useSymbol = false;
          setupGeneralInterpreter();
        }

        rules = definemorerules([], rules);
        library = definemorerules([], rules);
        roles = findroles(library);
        state = findinitsFn(library);
        tree = makeNode(state, null, null);

        const headstartDeadline = Date.now() + startclock * 1000;
        let iterations = 0;

        while (Date.now() < headstartDeadline) {
          processMCS(tree);
          iterations++;
          if (logging && iterations % 1000 === 0) {
            var timeRemaining = Math.max(0, (headstartDeadline - Date.now()) / 1000);
            console.log("Headstart - Time remaining: " + timeRemaining.toFixed(1) + 
                        "s, iterations: " + iterations);
          }
        }

        if (metrics) {
          const treeSize = countNodes(tree);
          const treeDepth = getTreeDepth(tree);
          console.log("Headstart complete - " + iterations + " iterations, " + 
                      depthCharges + " depth charges, " + nodesExplored + " nodes explored");
          console.log("Tree size: " + treeSize + " nodes, max depth: " + treeDepth);
        }

        return "ready";
      }

      // setup general interpreter functions
      function setupGeneralInterpreter() {
        findinitsFn = generalFindinits;
        findlegalsFn = generalFindlegals;
        simulateFn = generalSimulate;
        findcontrolFn = generalFindcontrol;
        findterminalpFn = generalFindterminalp;
        findrewardFn = generalFindreward;

        console.log("Using general interpreter");
      }

      // play function with threat detection and MCTS
      function play(rawMove) {
        var move = rawMove;

        if (useSymbol && move !== nil && move !== null) {
          move = symbolizeatom(move);
        }

        if (move !== nil && move !== null) {
          tree = subtree(move, tree);
          state = tree.state;
        }

        if (findcontrolFn(state, library) !== role) {
          return false;
        }

        if (metrics) {
          depthCharges = 0;
          nodesExplored = 0;
        }

        const opponentMoves = findlegalsFn(state, library);
        const oneturnLosses = opponentMoves.filter(function(opponentMove) {
          const nextState = simulateFn(opponentMove, state, library);
          return findterminalpFn(nextState, library) && 
                parseInt(findrewardFn(role, nextState, library)) === 0;
        });

        if (oneturnLosses.length > 0) {
          console.log("Found " + oneturnLosses.length + " one-turn losses, looking for counter");
          const myMoves = shuffle(findlegalsFn(state, library));
          for (let i = 0; i < myMoves.length; i++) {
            const curMove = myMoves[i];
            const afterMyMove = simulateFn(curMove, state, library);
            const opponentReplies = findlegalsFn(afterMyMove, library);
            if (oneturnLosses.every(function(loss) { 
              return !opponentReplies.includes(loss); 
            })) {
              console.log("Found move avoiding one-turn loss");
              return useSymbol ? unsymbolizeatom(curMove) : curMove;
            }
          }
          console.log("No perfect defense found, using first legal move");
          return useSymbol ? unsymbolizeatom(myMoves[0]) : myMoves[0];
        }

        const bestMove = playmcs();

        if (metrics) {
          const treeSize = countNodes(tree);
          const treeDepth = getTreeDepth(tree);
          console.log("Move selected");
          console.log("- Depth charges: " + depthCharges);
          console.log("- Nodes explored: " + nodesExplored);
          console.log("- Tree size: " + treeSize + " nodes, max depth: " + treeDepth);
          console.log("- Selected move: " + bestMove);
        }

        return useSymbol ? unsymbolizeatom(bestMove) : bestMove;
      }

      // run MCTS until deadline
      function playmcs() {
        const deadline = Date.now() + Math.max(playclock - 1, 0) * 1000;
        let iterations = 0;

        while (Date.now() < deadline) {
          processMCS(tree);
          iterations++;
          if (logging && iterations % 1000 === 0) {
            const timeRemaining = Math.max(0, (deadline - Date.now()) / 1000);
            console.log("Time remaining: " + timeRemaining.toFixed(1) + "s, iterations: " + iterations);
          }
        }

        return selectBestUCTMove(tree);
      }

      // create new node with state and move
      function makeNode(state, parent, move) {
        if (metrics) {
          nodesExplored++;
        }

        return {
          state: state,
          parent: parent,
          move: move,
          w: 0,
          n: 0,
          children: [],
          untried: shuffle(findlegalsFn(state, library))
        };
      }

      // single MCTS iteration with selection, expansion, simulation, backpropagation
      function processMCS(root) {
        var node = root;

        while (node.untried.length === 0 && node.children.length > 0) {
          node = bestUCTChild(node);
        }

        if (node.untried.length > 0) {
          const move = node.untried.pop();
          const newState = simulateFn(move, node.state, library);
          const child = makeNode(newState, node, move);
          node.children.push(child);
          node = child;
        }

        const reward = runDepthCharge(node.state);

        while (node) {
          node.n += 1;
          node.w += reward;
          node = node.parent;
        }
      }

      // select child using UCT formula
      function bestUCTChild(node) {
        var bestScore = -Infinity;
        var bestNode = node.children[0];

        for (var i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const exploit = child.w / child.n;
          const explore = C * Math.sqrt(Math.log(node.n) / child.n);
          const score = exploit + explore;

          if (score > bestScore) {
            bestScore = score;
            bestNode = child;
          }
        }

        return bestNode;
      }

      // find existing child node or create new one for move
      function subtree(move, node) {
        for (var i = 0; i < node.children.length; i++) {
          if (equalp(move, node.children[i].move)) {
            return node.children[i];
          }
        }

        const newState = simulateFn(move, node.state, library);
        return makeNode(newState, null, null);
      }

      // select move with best average reward
      function selectBestUCTMove(root) {
        if (!root.children || root.children.length === 0) {
          const legals = findlegalsFn(root.state, library);
          return legals.length > 0 ? legals[0] : null;
        }

        var bestChild = root.children[0];
        var bestValue = bestChild.w / bestChild.n;

        for (var i = 1; i < root.children.length; i++) {
          const child = root.children[i];
          const value = child.w / child.n;
          if (value > bestValue) {
            bestValue = value;
            bestChild = child;
          }
        }

        console.log("Selected move with " + bestChild.n + " visits");
        return bestChild.move;
      }

      // count total nodes in tree
      function countNodes(node, visited = new Set()) {
          if (!node || visited.has(node)) return 0;
          visited.add(node);

          var count = 1;
          for (var i = 0; i < node.children.length; i++) {
            count += countNodes(node.children[i], visited);
          }
          return count;
        }

      // get maximum depth of tree
      function getTreeDepth(node) {
        if (!node || node.children.length === 0) {
          return 1;
        }

        var maxChildDepth = 0;
        for (var i = 0; i < node.children.length; i++) {
          var childDepth = getTreeDepth(node.children[i]);
          if (childDepth > maxChildDepth) {
            maxChildDepth = childDepth;
          }
        }

        return 1 + maxChildDepth;
      }

      // random playout to terminal state
      function runDepthCharge(s) {
        depthCharges++;
        var state = s;
        var total = 0;

        while (!findterminalpFn(state, library)) {
          total += parseInt(findrewardFn(role, state, library), 10);
          const moves = findlegalsFn(state, library);
          if (moves.length === 0) break;
          state = simulateFn(moves[(Math.floor(Math.random() * (moves.length)))], state, library);
        }

        total += parseInt(findrewardFn(role, state, library), 10);
        return total;
      }

      function stop(move) { 
        return false; 
      }

      function abort() { 
        return false; 
      }

      function ping() { 
        return "ready"; 
      }
        
//==============================================================================
// End of player code
//==============================================================================
      </script>
  </head>

  <body bgcolor='#aabbbb' onload='doinitialize()'>
    <center>
      <table width='720' cellspacing='0' cellpadding='40' bgcolor='#ffffff'>
        <tr>
          <td>

            <center>
              <table width='640' cellpadding='0'>
                <tr>
                  <td width='180' align='center' valign='center'>
                    <img width='130' src='http://gamemaster.stanford.edu/images/ggp.jpg'/>
                  </td>
                  <td align='center'>
                    <span style='font-size:18pt'>&nbsp;</span>
                    <span style='font-size:32pt'>Gamemaster</span><br/>
                  </td>
                  <td width='180' align='center' style='color:#000066;font-size:18px'>
                    <i>General<br/>Game<br/>Playing</i>
                  </td>
                </tr>
              </table>
            </center>

            <br/>
            <table width='640' cellpadding='8' cellspacing='0' bgcolor='#f4f8f8' border='1'>
              <tr height='40'>
                 <td align='center'>
                  <table style='color:#000066;font-size:18px'>
                    <tr>
                      <td>
                  Protocol: localstorage<br/>
                  Strategy: mctsWithIndexingAndDepthCharges<br/>
                  Identifier: <span id='player'>aero</span> <img src="http://gamemaster.stanford.edu/images/pencil.gif" onclick='doplayer()'/>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
            <br/>

            <center>
              <br/>
              <textarea id='transcript' style='font-family:courier' rows='30' cols='80' readonly></textarea>
            </center>

          </td>
        </tr>
      </table>
    </center>
  </body>
</html>